# -*- coding: utf-8 -*-
"""trab1-desafio.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ay72WG9VqXSlqnhOJ5gDOYPI-vbDwX8_

DESAFIO - UVA 612 - DNA SORTING
"""

# Lab1 - Desafio UVA 612 - DNA SORTING
# Obs: nao conseguimos validar o resultado para todos os casos do arquivo de input de exemplo
# mas este foi o melhor resultado que obtivemos

#Importa bibliotecas
import math

## FUNCAO PARA AVALIAR O NIVEL DE SORTEDNESS DE UMA String

def unsortedness(asequence):
  counter = 0

  if len(asequence) == 1: # chegou no fim
    return 0 

  #marca o inicio da sequencia 
  i = 0
  start = asequence[0]

  # percorre a sequencia
  for letter in asequence:
    if start > letter: # se a primeira letra eh maior do que as outras
      counter += 1 # soma 1 ao counter
  i += 1
  return counter + unsortedness(asequence[i:len(asequence)]) # retorna o counter somado ao grau de sortedness do resto da sequencia

#  LENDO O INPUT

#The first line of the input is an integer M, then a blank line followed by M datasets. 
# There is a blank line between datasets. 
# The first line of each dataset contains two integers: 
# a positive integer n (0 < n ≤ 50) giving the length of the strings; 
# and a positive integer m (0 < m ≤ 100) giving the number of strings. 
# These are followed by m lines, each containing a string of length n.
  

# Leitura de arquivo txt
    # primeira linha tem M com o numero de datasets
    # depois linha em branco
    # depois n (length das strings) e m numero de strings
    # m linhas, cada uma com uma string de length n
  
def readFile(arquivo):
    linhas, entradas, numsComQtd = [], [], []

    #abre arquivo
    with open(arquivo, 'r') as arq:
        #lê linhas do arquivo
        linhas = arq.readlines()

    # primeira linha tem M com o numero de datasets
    M = int(linhas[0].strip())
   
    conjunto_dados = []  # variavel para todo o conjunto de dados

    # tira proxima linha em branco
    ponteiro_linha = 2

    # restam os M datasets com suas linhas

    # loop externo para percorrer os M datasets
    for _ in range(M):
      n, m = map(int, linhas[ponteiro_linha].split()) # pega n e m
      ponteiro_linha += 1

      dataset = []

      # loop interno para percorrer cada dataset 
      # le m linhas com as strings de tamanho n
      for _ in range(m):
        string = linhas[ponteiro_linha].strip()
        dataset.append(string)
        ponteiro_linha += 1 # vai pra proxima
      
      conjunto_dados.append((n,m, dataset)) # coloca o dataset numa dupla

      ponteiro_linha += 1 # pula a linha em branco

    return conjunto_dados # retorna o conjunto de dados


# Escreve resultado

def writeFile(arquivo, conteudo):

    with open(arquivo, 'a') as arq:
        linhas = arq.writelines(str(conteudo))
        arq.close()

### ---- GENERIC SORT ---- Função que usa as divisões calculadas para implementar um algoritmo "genérico" de Shell Sort
##

### ---- SHELL GAPS ---- Função para calcular as divisões "h" para o Shell Sort
def shellGap(arr):
  #usa log2 para calcular quantas vezes precisa dividir a lista ao meio
  n = math.floor(math.log2(len(arr)))
  n -= 1 
  arr = []

  #calcula lista de potências de dois para usar no shell short
  while n >= 0:
    arr.append(2**n)
    n -= 1

  #retorna a lista que foi calculada
  return arr

def genericShellSort(alist, gapsSequence): # FUNCAO GENERICA PARA ORDENAR

    if len(gapsSequence)>0:
      sublistcount = gapsSequence[0]
    
    while len(gapsSequence) > 0:

      gapsSequence.pop(0)   # pops first element (que ele ja selecionou)

      for startposition in range(sublistcount):
        gapInsertionSort(alist,startposition,sublistcount)

      if len(gapsSequence) > 0:   # CONFERE NOVAMENTE SE NAO ESGOTOU O ARRAY DE GAPS
        sublistcount = gapsSequence[0]  # seleciona o que ficou em primeiro
    
    return alist    #retorna a lista ordenada

def gapInsertionSort(alist,start,gap):  # CHAMA O INSERTION SORT 
    for i in range(start+gap,len(alist),gap):

        currentvalue = alist[i]
        position = i

        while position>=gap and alist[position-gap]>currentvalue:
            alist[position]=alist[position-gap]
            position = position-gap

        alist[position]=currentvalue

# FUNCAO MAIN

#Lê arquivos de entradas fornecidos:

#Lê arquivo "entrada1.txt"
listaEntradas1 = readFile('/content/input612.txt')

# calcula cada dataset
# coloca o resultado na saida

lista_de_unsortedness = []
listaFinal = []

for i in range(len(listaEntradas1)): # comeca em zero
  # The first line of each dataset contains two integers: 
  # a positive integer n (0 < n ≤ 50) giving the length of the strings; 
  # and a positive integer m (0 < m ≤ 100) giving the number of strings.
  n = listaEntradas1[i][0] # pega o valor de n
  m = listaEntradas1[i][1] # pega o valor de m

  #limpa as listas
  lista_ordenada.clear()
  lista_de_unsortedness.clear()
  listaFinal.clear()
  dicionario = {}

  print(i)
  print(listaEntradas1[i])
  j = 0
  print(m)
  lista_de_unsortedness = []
  for j in range(m): #percorre o interior do dataset
    temp = unsortedness(listaEntradas1[i][2][j]) #calcula o nivel de unsortedness de cada palavra 
    lista_de_unsortedness.append(temp) # armazena em outra lista  

    # solucao melhor, mas que ainda apresenta problemas
    # pois o dicionario nao aceita keys repetidas

    dicionario.update({listaEntradas1[i][2][j]: temp})  
    #print(lista_de_unsortedness)  

  #lista_ordenada = genericShellSort(lista_de_unsortedness.copy(), shellGap(lista_de_unsortedness)) # ordena a lista de valores de unsortedness
  sorted_dict = dict(sorted(dicionario.items(), key=lambda item: item[1]))
  print(sorted_dict)

  listaFinal = list(sorted_dict.keys())
  print(listaFinal)

  for k in range(m): #percorre de novo
    if len(listaFinal)>0 and k < len(listaFinal):
      string_to_write = str(listaFinal[k]) + '\n'
      writeFile('/content/saida_desafio.txt', string_to_write)

# raciocinio inicial (que deu errado pois nao havia conexao entre os valores de unsortedness e as entradas, gerando problemas
# com valores repetidos
  #for k in range(m): # percorre de novo a lista de unsortedness
   # h = 0
   #for h in range(m): # percorre por dentro a lista de entradas e o valor de unsortedness de cada
      #if lista_ordenada[k] == unsortedness(listaEntradas1[i][2][h]): #acha o elemento com o mesmo valor
       # print(unsortedness(listaEntradas1[i][2][h]))
        #print(listaEntradas1[i][2][h])
        #listaFinal.append(listaEntradas1[i][2][h])  # coloca na lista final 
        #print(listaFinal)
        # escreve no arquivo
        #string_to_write = str(listaFinal[k]) + '\n'
        #writeFile('/content/saida2.txt', string_to_write)
      
  writeFile('/content/saida2.txt','\n')

